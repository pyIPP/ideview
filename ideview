#!/usr/bin/env python 
# -*- coding: utf-8 -*-

import os
import platform

if platform.system() != 'Linux':
    print 'Please use "toksXX". i.e. "ssh toksXX" where "XX" means numbers between 01-06'
    sys.exit()

try:
    import sys, numpy as np, matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
    import matplotlib.gridspec as gridspec
    from matplotlib.figure import Figure
    from IPython import embed
    sys.path.append('/afs/ipp/aug/ads-diags/common/python/lib')
    from lib.settings import Settings
    from lib.backend import ShotfileBackend

    import kk_abock as kk
    sys.path.append('/afs/ipp/home/g/git/python/repository/')
    from functools import partial


    from tooltip import createToolTip

except ImportError, e:
    print e
    print 'Did you do "module load python27/basic"?'
    sys.exit()

def fconf_on_click(event):
    """
    Enlarge or restore the selected axis.
    Usage: figure.canvas.mpl_connect('button_press_event', fconf.on_click)
    """
    ax = event.inaxes
    full_screen_pos = (0.1, 0.1, 0.85, 0.85)
    #print ax.get_position().bounds
    #if (np.array(full_screen_pos) - np.array(ax.get_position().bounds)) <= 0.01:
        #print 'Works'
    if ax is None:
        # Occurs when a region not in an axis is clicked...
        return
    if event.button is 2: # 2 middle mouse, 3 right mouse
        # On left click, zoom the selected axes
        if not (np.abs(np.array(full_screen_pos) -
np.array(ax.get_position().bounds))).sum() <= 0.01:
            ax._orig_position = ax.get_position()
            ax.set_position([0.1, 0.1, 0.85, 0.85])
            for axis in event.canvas.figure.axes:
            # Hide all the other axes...
                if axis is not ax:
                    axis.set_visible(False)
    #elif event.button is 3:
        # On right click, restore the axes
        else:
            try:
                ax.set_position(ax._orig_position)
                for axis in event.canvas.figure.axes:
                    axis.set_visible(True)
            except AttributeError:
            ## If we haven't zoomed, ignore...
                pass
    else:
        # No need to re-draw the canvas if it's not a left or right click
        return
    event.canvas.draw()

import Tkinter as tk
import ttk

#TODO Allow comparims with more different equlibria (TRA,EQH,i...)
#TODO add my special equilibria? 


# config.py? 

    
class Data(): data = None

class StatusBar(tk.Frame):
    def __init__(self, master):
        tk.Frame.__init__(self, master)
        self.variable = tk.StringVar()
        self.label = tk.Label(self, bd=1, relief=tk.SUNKEN, anchor=tk.W,
                           textvariable=self.variable)
        self.variable.set('')
        self.label.pack(fill=tk.X)        
        self.pack(side=tk.BOTTOM, fill=tk.X)

    def setText(self, text):
        self.variable.set(text)


class View(tk.Tk):
    backend = None

    def __init__(self, parent):
        tk.Tk.__init__(self, parent)
        self.parent = parent
        self.initialize()

    def embed(self):
        embed()

    def status(self, text):
        self.statusbar.setText(text)

    def initialize(self):
        self.settings = Settings()

        menubar = tk.Menu(self)
        filemenu = tk.Menu(menubar, tearoff=0)
        #filemenu.add_command(label="Open")
        #filemenu.add_command(label="Save")
        #filemenu.add_separator()
        filemenu.add_command(label="Exit", command=self.Quit)
        menubar.add_cascade(label="File", menu=filemenu)

        viewmenuNeu = tk.Menu(menubar, tearoff=0)
        viewmenuNeu.add_command(label='Select Plot Items', command= self.Selection)
        menubar.add_cascade(label="View", menu=viewmenuNeu)

        debugmenu = tk.Menu(menubar, tearoff=0)
        debugmenu.add_command(label="IPython.embed()", command=self.embed)
        menubar.add_cascade(label="Debug", menu=debugmenu)

        self.config(menu=menubar)

        self.statusbar = StatusBar(self)

        self.topframe = tk.Frame(self)
        self.topframe.pack(side=tk.TOP, fill=tk.X)
        
        def_set = (('Diag',4),('Exp',7),('Shot',5),('Ed',2))
        
        for name,width in def_set:
                
            label = tk.Label(self.topframe, text=' '+name+':')
            label.pack(side=tk.LEFT)
            setattr(self, 'entry'+name, tk.Entry(self.topframe, width=width))
            entry = getattr(self,'entry'+name)
            entry.pack(side=tk.LEFT)
            entry.insert(0, getattr(self.settings,'last'+name))
            
 
        #self.topframe2 = tk.Frame(self)
        #self.topframe2.pack(side=tk.TOP, fill=tk.X)
        
        #for name,width in def_set:
                
            #label = tk.Label(self.topframe2, text=' '+name+':')
            #label.pack(side=tk.LEFT)
            #setattr(self, 'entry'+name, tk.Entry(self.topframe2, width=width))
            #entry = getattr(self,'entry'+name)
            #entry.pack(side=tk.LEFT)
            #entry.insert(0, getattr(self.settings,'last'+name))
            

        button_load = tk.Button(self.topframe, text="Load", command=self.onLoadButtonClick)
        button_load.pack(side=tk.LEFT)

        button_backward = tk.Button(self.topframe, text="<", command=self.onPrevButtonClick)
        button_backward.pack(side=tk.LEFT)

        self.playString = u"  \u25B6 "
        self.pauseString = u"\u275A\u275A"
        self.playButton = tk.Button(self.topframe, text=self.playString, command=self.onPlayButtonClick)
        self.playButton.pack(side=tk.LEFT)

        button_forward = tk.Button(self.topframe, text=">", command=self.onNextButtonClick)
        button_forward.pack(side=tk.LEFT)

        #self.timeslider = tk.Scale(self.topframe, orient="horizontal", command=self.scaleUpdated, from_=0, to=0, resolution=0)
        self.timeslider = tk.Scale(self.topframe, orient="horizontal", from_=0, to=0, resolution=0)
        self.timeslider.bind("<ButtonRelease-1>", self.scaleUpdated)
        #embed()
        self.timeslider.pack(side=tk.LEFT, fill=tk.X, expand=1)

        self.viewfig = Figure()
        self.canvas = FigureCanvasTkAgg(self.viewfig, master=self)
        self.canvas.show()
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        self.bind('<Control-q>', self.Quit)
        self.bind('<space>', self.onPlayButtonClick)
        self.bind('<Return>', self.onLoadButtonClick)

        toolbar = NavigationToolbar2TkAgg(self.canvas, self)
        toolbar.update()

        toolframe = tk.Frame(self, height=45)
        toolframe.pack_propagate(0)
        toolframe.pack(side=tk.TOP, fill=tk.X)

        self.geometry(self.settings.windowConditions)
        self.bind("<Configure>", self.onResize)

        #TODO  remove
        #self.onLoadButtonClick()
        #self.entryShot.delete(0, tk.END)
        #self.entryShot.insert(0, "31113")
        #self.onLoadButtonClick()
        #self.viewSettings()
        
        #self.cid1 = self.viewfig.canvas.mpl_connect('button_press_event',self.MouseInteraction)
        self.cid2 = self.viewfig.canvas.mpl_connect('scroll_event',self.MouseWheelInteraction)
        #self.cid3 = self.viewfig.canvas.mpl_connect('key_press_event',   self.on_key)
        #self.cid4 = self.viewfig.canvas.mpl_connect('key_release_event', self.off_key)
        
        self.viewfig.canvas.mpl_connect('button_press_event', fconf_on_click)

        #createToolTip(self.timeslider,'Can be controlled also by mouse wheel')
        createToolTip(button_backward,'Go backward by one timestep, (also right mouse button)')
        createToolTip(self.playButton,'Play,Stop, also controlled by mouse middle button and <space>')
        createToolTip(button_forward,'Go forward by one timestep, (also left mouse button)')

    
    def Selection(self):

        if self.backend == None:
            print 'Please load Shotfile first.'
            return
        if hasattr(self, 'toplevel'):
            self.toplevel.destroy()
        self.toplevel = tk.Toplevel(self)
        self.toplevel.resizable(0,0)
        self.toplevel.wm_title('Selection')
        n = ttk.Notebook(self.toplevel)
        f1 = ttk.Frame(n)
        f2 = ttk.Frame(n)
        f3 = ttk.Frame(n)
        f4 = ttk.Frame(n)
        f5 = ttk.Frame(n)
        n.add(f1, text='Profiles')
        n.add(f2, text='Residua')
        n.add(f3, text='Traces')
        n.add(f4, text='Timecontours')
        n.add(f5, text='Contours')

        selected = self.settings.selectedPlots
        available = self.backend.getAvailablePlotNames()
        boxvars = {}

        selectedgyros = self.settings.selectedGyrotrons
        availablegyros = self.backend.getAvailableGyrotrons()
        gyrovars = {}

        for name in available:
            boxvars[name] = tk.IntVar()
        for i in range(availablegyros):
            gyrovars[i] = tk.IntVar()

        def updatePlotSelection(name_=None, frame=None, row_=None):
            self.settings.selectedPlots = [name for name in boxvars if boxvars[name].get()]
            j = len(self.settings.selectedPlots)
            #if name_ in self.settings.selectedPlots:
            self.makeentry(name_, self.settings.selectedPlots, frame, j, row_)
            #self.preparePlots()
            #self.updatePlots()

        def updateSelectedGyrotrons():
            self.settings.selectedGyrotrons = [gyronum for gyronum in gyrovars if gyrovars[gyronum].get()]
        
        
        allCheckboxes = []

        def selectNone(self):
            i=0
            while i < len(allCheckboxes):
                allCheckboxes[i].deselect()
                i += 1
            updatePlotSelection()
            updateSelectedGyrotrons()

        allNoneCb = []
        NoneCb1 = tk.Checkbutton(f1, text='None', onvalue=1, offvalue=0, command=partial(selectNone, self))
        allNoneCb.append(NoneCb1)
        NoneCb2 = tk.Checkbutton(f2, text='None', onvalue=1, offvalue=0, command=partial(selectNone, self))
        allNoneCb.append(NoneCb2)
        NoneCb3 = tk.Checkbutton(f3, text='None', onvalue=1, offvalue=0, command=partial(selectNone, self))
        allNoneCb.append(NoneCb3)
        NoneCb4 = tk.Checkbutton(f4, text='None', onvalue=1, offvalue=0, command=partial(selectNone, self))
        allNoneCb.append(NoneCb4)
        NoneCb5 = tk.Checkbutton(f5, text='None', onvalue=1, offvalue=0, command=partial(selectNone, self))
        allNoneCb.append(NoneCb5)
        for i, p in enumerate(allNoneCb):
            allNoneCb[i].grid(row=0, column=1, sticky=tk.W)
            allCheckboxes.append(allNoneCb[i])

        for i, name_ in enumerate(available):
            kind, parameter = name_.split('-')
            if kind == 'profile':
                cb = tk.Checkbutton(f1, text=parameter, variable=boxvars[name_], onvalue=1, offvalue=0, command=partial(updatePlotSelection, name_, f1, i))
            if kind == 'res(profile)':
                cb = tk.Checkbutton(f2, text=parameter, variable=boxvars[name_], onvalue=1, offvalue=0, command=partial(updatePlotSelection, name_, f2, i))
            if kind == 'trace':
                cb = tk.Checkbutton(f3, text=parameter, variable=boxvars[name_], onvalue=1, offvalue=0, command=partial(updatePlotSelection, name_, f3, i))
            if kind == 'timecontour':
                cb = tk.Checkbutton(f4, text=parameter, variable=boxvars[name_], onvalue=1, offvalue=0, command=partial(updatePlotSelection, name_, f4, i))
            if kind == 'contour':
                cb = tk.Checkbutton(f5, text=parameter, variable=boxvars[name_], onvalue=1, offvalue=0, command=partial(updatePlotSelection, name_, f5, i))

            if name_ in selected: 
                boxvars[name_].set(1)
                cb.select()
            
            cb.grid(row = i+2, column = 1, sticky=tk.W)
            allCheckboxes.append(cb)

            applybutton1 = tk.Button(f1, text='apply', command=self.apply_)
            applybutton2 = tk.Button(f2, text='apply', command=self.apply_)
            applybutton3 = tk.Button(f3, text='apply', command=self.apply_)
            applybutton4 = tk.Button(f4, text='apply', command=self.apply_)
            applybutton5 = tk.Button(f5, text='apply', command=self.apply_)
            applybutton1.grid(row = 0, column = 2)
            applybutton2.grid(row = 0, column = 2)
            applybutton3.grid(row = 0, column = 2)
            applybutton4.grid(row = 0, column = 2)
            applybutton5.grid(row = 0, column = 2)
            if name_ == 'contour-rho':
                for j in range(availablegyros):
                    CB = tk.Checkbutton(f5, text = 'gyro%i'%(j+1), variable = gyrovars[j], onvalue = 1, offvalue = 0, command = partial(updateSelectedGyrotrons))
                    CB.grid(row = i+j+2, column = 2, sticky = tk.W)
                    allCheckboxes.append(CB)
                    if j in selectedgyros:
                        gyrovars[j].set(1)
                        CB.select()

        n.grid()

    def apply_(self):
        self.preparePlots()
        self.updatePlots()


    def makeentry(self, name, checked, f, j, i):        # TODO entries beneath selectable options for decide in which plot they should be displayed
        return
        if name in checked:
            setattr(self, 'entry'+name, tk.Entry(f, width=2))
            entry = getattr(self,'entry'+name)
            entry.grid(row=i, column=2)
            entry.insert(0, j)
        else:
            if hasattr(self, 'entry'+name):
                entry_ = getattr(self,'entry'+name)
                entry_.grid_forget()

    def Quit(self, event=None):
        sys.exit()

    def onResize(self, event):
        if event.widget == self:
            self.settings.windowConditions = self.geometry()

    playing = False

    def onPrevButtonClick(self):
        res = self.timeslider.config()['resolution'][-1]
        from_ = self.timeslider.config()['from'][-1]
        if not self.timeslider.get() - res < from_:
            self.timeslider.set(self.timeslider.get()-res)
            self.updatePlots()

    def onNextButtonClick(self):
        res = self.timeslider.config()['resolution'][-1]
        to = self.timeslider.config()['to'][-1]
        if not self.timeslider.get() + res > to:
            self.timeslider.set(self.timeslider.get()+res)
            self.updatePlots()

    def onPlayButtonClick(self, event=None):
        btn = self.playButton
        if btn.config()['text'][-1] == self.playString:
            btn.configure(text=self.pauseString)
            self.playing = True
            self.status('Playing...')
            self.playLoop()
        else:
            btn.configure(text=self.playString)
            self.playing = False            
            self.status('')

    def playLoop(self):
        if not self.playing:
            self._job = None
            return
        res = self.timeslider.config()['resolution'][-1]
        to = self.timeslider.config()['to'][-1]
        from_ = self.timeslider.config()['from'][-1]
        if self.timeslider.get() + res < to:
            self.timeslider.set(self.timeslider.get() + res)
            self.updatePlots()
            self._job = self.after(10, self.playLoop)
        else:
            self.playButton.configure(text=self.playString)
            self.playing = False            
            self.status('')

    def onLoadButtonClick(self, event=None):
        self.settings.lastDiag = self.entryDiag.get()
        self.settings.lastExp = self.entryExp.get()
        self.settings.lastShot = self.entryShot.get()
        self.settings.lastEd = self.entryEd.get()
        self.load(self.entryDiag.get(), self.entryExp.get(), 
                  self.entryShot.get(), self.entryEd.get())

    def MouseWheelInteraction(self,event):
        res = self.timeslider.config()['resolution'][-1]
        to = self.timeslider.config()['to'][-1]
        from_ = self.timeslider.config()['from'][-1]
        time = max(from_ ,min(to,self.timeslider.get()+res*event.step))
        self.timeslider.set(time)
        self.updatePlots()

    structures = []
    loaded = False

    def load(self,diag, exp, shot, edition):   
        self.loaded = False
        self.status('Loading %s %s #%s.%s'%(diag,exp,shot,edition))
        self.backend = ShotfileBackend(diag,exp, int(shot), int(edition))
        t = self.backend.getAvailableTimes()
        self.timeslider.configure(from_=t.min(), to=t.max(), resolution=(t[-1]-t[0])/len(t))
        # EXAMPLE: 3 tickintervals: self.timeslider.configure(tickinterval=(t[-1]-t[0])/3)
        self.timeslider.set(t.min())

        eq = kk.kk()
        eq.Open(int(shot), 'AUGD', 'YGC')
        self.structures = eq.get_vessel_structures()

        oe = self.backend.openedEditions
        keys = oe.keys()
        keys.sort()
        editions = ' '.join(['%s:%i'%(key, oe[key]) for key in keys])
        self.status('Loaded: %s:%s #%s %s'%(exp,diag,shot,editions))

        self.preparePlots()
        if not self.loaded: self.updatePlots()
        self.loaded = True

    def preparePlots(self):

        self.viewfig.clf()
        self.__firstplot = True
        plt.rc('legend',**{'fontsize':'12'})
        s = ' '.join(self.settings.selectedPlots)
        Nc = s.count('contour') - s.count('timecontour')
        Np = s.count('profile')
        Nt = s.count('trace') + s.count('timecontour')
        Nw, Nh = 1, 0
        if Np == 1 and Nc == 0 and Nt == 0:
            Nw=1
            Nh=1
        else:
            while Nw*Nh < Np:
                Nw += 1
                if  Nw*Nh >= Np:
                    break
                Nh += 1

        gs = gridspec.GridSpec(Nh+Nt, Nw+Nc) if Np+Nt != 0 else gridspec.GridSpec(Nw, Nc)
        Cc, Cp, Ct = 0, 0, 0
        self.axes = {}
        for i, name in enumerate(self.settings.selectedPlots):
            if 'trace' in name or 'timecontour' in name:
                Ct += 1
                self.axes[name] = self.viewfig.add_subplot(gs[-Ct, :-Nc]) if Nc != 0 else \
                                  self.viewfig.add_subplot(gs[-Ct, :])
            elif 'contour' in name:
                Cc += 1
                self.axes[name] = self.viewfig.add_subplot(gs[:, -Cc])
            else:
                Cp += 1
                yi = (Cp - 1)%Nw
                xi = int((Cp-1)/Nw)
                self.axes[name] = self.viewfig.add_subplot(gs[xi,yi])

        if len(self.axes) > 0:
            self.viewfig.tight_layout(pad=3.5)  
        self.canvas.draw()

    __firstplot = True
    def updatePlots(self):
        
        self._job = None

        if self.backend == None:
            return

        if self.__firstplot:  
            self._linecache = {}

        t = float(self.timeslider.get())
        plots = self.backend.getPlotsForTimePoint(self.settings.selectedPlots, t)
        # performance is fine until here, so optimise what comes next


        for i, key in enumerate(self.axes):
            ax = self.axes[key]
            
            if not (key in plots):
                continue

            ps = plots[key]
            if not hasattr(ps, 'data'):
                continue
            
            if self.__firstplot:
                ax.cla()
                #setting
                if hasattr(ps, 'setting'): ax.set(**ps.setting)
                #if 'contour' not in ps.kind: ax.legend(loc='best')
                
                if ps.kind == 'contour': 
                    for s in self.structures:
                        if max(s['z']) - min(s['z']) < 1.5:
                            ax.fill(s['R'], s['z'], 'LightGray',zorder=99)
                        ax.plot(s['R'], s['z'], 'Black',zorder=99)
                        
                elif (not hasattr(ps, 'setting') or not 'xlim' in  ps.setting) and ps.kind != 'profile':
                    ax.set_xlim(self.backend.getAvailableTimes().min(), 
                                self.backend.getAvailableTimes().max())
            
            #TODO dít ten forcyklus ven?? ušetří se pak pár řádků? == Data for the cycle out ?? then saving a few lines
            if ps.kind in ('profile', 'trace'):
                tmp = None
                if self.__firstplot:
                    ax.grid('on')

                for j, p in enumerate(ps.data):

                    cachekey = '%i%s%i'%(i, key, j)
                    x = p.pop('x') if 'x' in p else ax.get_xlim()
                    y = p.pop('y') if 'y' in p else ax.get_ylim()
                    #yerr = p.pop('yerr') if 'yerr' in p else None
                    exc = p.pop('exc') if 'exc' in p else False

                    if np.size(x) == 1: x = [x,x]
                    if np.size(y) == 1: y = [y,y]

                    if cachekey in self._linecache:
                        self._linecache[cachekey].set_data(x,y)

                    else:
                        c = 'b'
                        if not exc: #'normal' profiles and traces
                            label = key.split('-')[-1] if '-' in key and j==0 else None
                            tmp, =  ax.plot(x, y, label=label,color=c, **p)
                            #for errorbars in constraints
                            '''if yerr is not None:
                                tmp, = ax.errorbar(x,y,yerr=yerr, label=label,color=c, **p)
                            else:
                                tmp, =  ax.plot(x, y, label=label,color=c, **p)'''
                        else:       #exceptions like residua
                            tmp, =  ax.plot(x, y, **p)

                        self._linecache[cachekey] = tmp

                        
            elif ps.kind == 'timecontour':
                if self.__firstplot:
                    ax.grid('on')
                    
                for j, p in enumerate(ps.data):
                    cachekey = '%i%s%i'%(i, key, j)
                    #print cachekey, self._linecache.keys()
                    #if i==5: embed()
                    
                    if not 'z' in p:
                        x = p.pop('x') if 'x' in p else ax.get_xlim()
                        y = p.pop('y') if 'y' in p else ax.get_ylim()

                        if np.size(x) == 1: x = [x,x]
                        if np.size(y) == 1: y = [y,y]

                        if cachekey in self._linecache:
                            self._linecache[cachekey].set_data(x,y)
                            
                        else:
                            tmp, = ax.plot(x, y,color='k', **p)
                            self._linecache[cachekey] = tmp
                            

                            
                    else:
                        x,y,z = p.pop('x'), p.pop('y'), p.pop('z')

                        if not cachekey in self._linecache:
                            tmp = ax.contour(x, y, z.T, **p)
                            if key.split('-')[-1] == 'q':
                                labels = []
                                for l in range(len(tmp.levels)):
                                    labels.append(tmp.levels[l])
                                for l in range(len(labels)):
                                    tmp.collections[l].set_label(labels[l])

                            ax.set_title(key.split('-')[-1])
                            self._linecache[cachekey] = tmp
                            
                            
            elif ps.kind == 'contour':
                if (len(ps.data) > 1):   #ecrhpos
                    
                    for j, p in enumerate(ps.data):
                        cachekey = '%i%s%i'%(i, key, j)
                        if 'z' not in p and (j>0):
                            #embed()
                            
                            x = p.pop('x') if 'x' in p else ax.get_xlim()
                            y = p.pop('y') if 'y' in p else ax.get_ylim()
                            gyrInd = p.pop('gyro_ind') if 'gyro_ind' in p else None                            
                            if not gyrInd is None and not gyrInd in self.settings.selectedGyrotrons:
                                continue

                            if np.size(x) == 1: x = [x,x]
                            if np.size(y) == 1: y = [y,y]
                            if cachekey in self._linecache:
                                self._linecache[cachekey].set_data(x,y)
        
                            else:
                                c = 'b'
                                tmp, =  ax.plot(x, y, color=c, **p)
                                self._linecache[cachekey] = tmp

                        elif 'z' not in p and j==0:
                            x = p.pop('x') if 'x' in p else ax.get_xlim()
                            y = p.pop('y') if 'y' in p else ax.get_ylim()
                            if np.size(x) == 1: x = [x,x]
                            if np.size(y) == 1: y = [y,y]
                            if cachekey in self._linecache:
                                self._linecache[cachekey].set_data(x,y)
        
                            else:
                                c = 'b'
                                tmp, =  ax.plot(x, y, color=c, **p)
                                self._linecache[cachekey] = tmp
                        else:
                            x,y,z = p.pop('x'), p.pop('y'), p.pop('z')
                            if self.__firstplot:
                                ax.set_aspect('equal') 
                                ax.axis([1,2.2,-1.2,1.1 ])
                                ax.set_title(key.split('-')[-1])
        
                            if cachekey in self._linecache:
                                C = self._linecache[cachekey]
                                for coll in C.collections:
                                    ax.collections.remove(coll) 
                            if 'rho' in key:
                                z = 1 - z  #NOTE just to plot lines out of the separatrix by dashed lines 
                                p['levels'] = 1- p['levels']
    
                            self._linecache[cachekey] = ax.contour(x, y, z,colors='k',**p)
                else:
    
                    for j, p in enumerate(ps.data):
                        cachekey = '%i%s%i'%(i, key, j)
                        if 'z' not in p:
                            x = p.pop('x') if 'x' in p else ax.get_xlim()
                            y = p.pop('y') if 'y' in p else ax.get_ylim()
                            if np.size(x) == 1: x = [x,x]
                            if np.size(y) == 1: y = [y,y]
                            if cachekey in self._linecache:
                                self._linecache[cachekey].set_data(x,y)
        
                            else:
                                c = 'b'
                                tmp, =  ax.plot(x, y, color=c, **p)
                                self._linecache[cachekey] = tmp
                        else:
                            x,y,z = p.pop('x'), p.pop('y'), p.pop('z')
                            if self.__firstplot:
                                ax.set_aspect('equal') 
                                ax.axis([1,2.2,-1.2,1.1 ])
                                ax.set_title(key.split('-')[-1])
        
                            if cachekey in self._linecache:
                                C = self._linecache[cachekey]
                                for coll in C.collections:
                                    ax.collections.remove(coll) 
                            if 'rho' in key:
                                z = 1 - z  #NOTE just to plot lines out of the separatrix by dashed lines 
                                p['levels'] = 1- p['levels']
    
                            self._linecache[cachekey] = ax.contour(x, y, z,colors='k',**p)


            if ps.kind != 'contour' and self.__firstplot:
                if key.split('-')[-1] != 'q' and ps.kind == 'timecontour':
                    break
                leg = ax.legend(loc='upper right', fancybox=True)
                leg.get_frame().set_alpha(0.7)
                for legobj in leg.legendHandles:
                    legobj.set_linewidth(2.0)                

                

        self.__firstplot = False

        self.canvas.draw()

    
    def scaleUpdated(self, event):
        self.updatePlots()
        #if not self.playing:
        #    self._job = self.after(200, self.updatePlots)
        


if __name__ == "__main__":
    app = View(None)
    
    #app.initialize()
    #app.load('TRE', 'TODSTRCI', 30579, 0)
    
    app.title('Equlibrium viewer')
    app.mainloop()

